#!/usr/bin/env node

const argv = require('minimist')(process.argv.slice(2));
const async = require('async');
const tape = require('tape');
const path = require('path');
const cp = require('child_process');

if (argv.r) {
  randomized(argv.r);
} else if (argv.s) {

  var hrstart = process.hrtime();
  runTests('state', argv, function(){
    var hrend = process.hrtime(hrstart);
    console.log('# Execution time (hr): %ds %dms', hrend[0], hrend[1] / 1000000);
  });
} else if (argv.v) {
  runTests('vm', argv);
} else if(argv.t){
  runTests('transaction', argv);
} else if (argv.a) {
  runAll();
}

//randomized tests
//returns 1 if the tests fails
//returns 0 if the tests succeds
function randomized(stateTest) {
  const stateRunner = require('../test/stateRunner.js');

  tape.createStream({
    objectMode: true
  }).on('data', function(row) {
    if (row.ok === false) {
      process.stdout.write('1');
      process.exit();
    }
  }).on('end', function() {
    process.stdout.write('0');
  });

  try {
    stateTest = JSON.parse(stateTest);
  } catch (e) {
    console.error('invalid json');
    process.exit();
  }

  tape('', function(t) {
    stateRunner(stateTest, {
      t: t
    }, function() {
      t.end();
    });
  });
}

function getTests(type, argv) {
  
  if(argv.local){
    var base = path.basename(argv.local);
    return {
      base : require(argv.local)
    };
  }

  var tests = require('ethereum-tests')[type + 'Tests'];

  if (type === 'vm') {
    for (var prop in tests.randomTest) {
      tests[prop] = tests.randomTest[prop];
    }

    delete tests.RandomTests;
    delete tests.vmSystemOperationsTest;
  }

  //for running a single file
  if (argv.file) {
    var i = {};
    i[argv.file] = tests[argv.file];

    //run a single test from a single file
    if (argv.test) {
      i[argv.file] = {};
      i[argv.file][argv.test] = tests[argv.file][argv.test];
    }

    tests = i;
  }

  return tests;
}

function runTests(type, argv, cb) {
  var tests = getTests(type, argv);
  const runner = require('../test/' + type + 'Runner');
  const skip = ['TransactionMakeAccountBalanceOverflow', 'RecursiveCreateContracts'];

  //run all of the tests
  async.eachSeries(Object.keys(tests), function(fileName, done) {
    var file = tests[fileName];
    async.eachSeries(Object.keys(file), function(testName, done2) {
      var test = file[testName];
      tape('[' + fileName + '] ' + testName, function(t) {
        if(skip.indexOf(testName) === -1){
          runner(test, {
            t: t,
            vmtrace: argv.vmtrace
          }, function() {
            t.end();
            done2();
          });
        }else{
          t.skip('testName');
          t.end();
          done2();
        }
      });
    }, done);
  }, cb);
}

function runAll() {
  async.series([
    function(done) {
      var f = cp.fork(__dirname + '/../test/tester.js');
      f.on('close', done);
    },
    function(done) {
      var f = cp.fork(__dirname + '/../test/browserfy.js');
      f.on('close', done);
    },
    function(done) {
      var f = cp.fork(__dirname + '/../test/transactions.js');
      f.on('close', done);
    },
    function(done) {
      var f = cp.fork(__dirname + '/../test/genesishashes.js');
      f.on('close', done);
    },
    // runTests.bind(this, 'transaction', {}),
    runTests.bind(this, 'state', {}),
    runTests.bind(this, 'vm', {})
  ]);
}
